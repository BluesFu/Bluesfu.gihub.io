<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content>
    <meta name="author" content>
    <meta name="keywords" content>
    <title>Hexo</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/mdb.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_vr10bjtg3us.css">
    
        <link rel="stylesheet" href="/css/Prettify/tomorrow-night-eighties.min.css">
    
</head>

<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/"><strong>Hexo</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">About</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2" style='background: url("https://api.dujin.org/bing/1920.php")no-repeat center center;background-size: cover;'>
    <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
        <div class="container text-center white-text wow fadeInUp">
            <p class="h2"></p>
            <br>
            
            <p>Monday, June 3rd 2019, 10:41 pm</p>
            
        </div>
        </div>
    </div>
    </div>
  </header>

  <main>
  
  <div class="container-fluid">
    <div class="row">
        <div class="col-md-8 offset-md-2 ">
            <div class="post-content py-5 z-depth-3 main">
                <h1 id="复用类"><a href="#复用类" class="headerlink" title="复用类"></a>复用类</h1><h2 id="java继承"><a href="#java继承" class="headerlink" title="java继承"></a>java继承</h2><p>可以基于已经存在的类构造一个新的类。继承已经存在的类就可以复用这个类的方法和域。在此基础上，可以添加新的方法和域，从而扩充新类的功能。</p>
<hr>
<ul>
<li>面向对象最重要的特点之一，就是可以实现对象的复用。</li>
<li>通过“继承”一个现有的类，可以使用已经定义的类中的方法和变量。</li>
<li>类的方法可以被继承，但是类的<code>构造器</code>和<code>用private修饰的属性及方法</code>不能被继承。</li>
</ul>
<h3 id="1-继承的基本语法"><a href="#1-继承的基本语法" class="headerlink" title="1. 继承的基本语法"></a>1. 继承的基本语法</h3><p>父类</p>
<pre><code class="java">public class Father{
  ...//属性
  ...(){//方法
    ...
  }
}</code></pre>
<p>子类</p>
<pre><code class="java">public class Son extends Father{

}</code></pre>
<h3 id="2-继承的概念"><a href="#2-继承的概念" class="headerlink" title="2. 继承的概念"></a>2. 继承的概念</h3><p>继承是面向对象最显著的一个特征。继承是从以有的类中派生出的新类，新类能吸收已有类的数据属性和方法，并且扩展新的能力。</p>
<p>基本语法如下：</p>
<pre><code class="java">class 子类 extends 父类{}</code></pre>
<p>java继承的基本实现</p>
<pre><code class="java">clss Animal{
  private int weight;
  private int age;


  public int getWeight() {
           return weight;
       }

       public void setWeight(int weight) {
           this.weight=weight;
       }

       public int getAge() {
           return age;
       }

       public void setAge(int age) {
           this.age=age;
       }
}
class Dog extends Animal{  //Dog类继承了Animal类

}

public class ExtendsDemo{
  public static void main(String[] args){
    Dog dog=new Dog();
    dog.setAge(5);
    dog.setWeight(10);
    dog.speak();
System.out.println(&quot;age:&quot;+dog.getAge+&quot;,weight:&quot;+dog.getWeight);


  }
}
</code></pre>
<p>运行结果:</p>
<pre><code class="java">age:5,weight10</code></pre>
<p>通过代码可以发现，子类（Dog）并没有定义任何的操作，而在主类中所使用的全部操作都是由Animal类定义的，这证明：子类即使不扩充父类，也能维持父类的操作。</p>
<p>在子类扩充父类的功能:</p>
<pre><code class="java">clss Animal{
  private int weight;
  private int age;


  public int getWeight() {
           return weight;
       }

       public void setWeight(int weight) {
           this.weight=weight;
       }

       public int getAge() {
           return age;
       }

       public void setAge(int age) {
           this.age=age;
       }
}
class Dog extends Animal{  //Dog类继承了Animal类
   private String color;

   public void speak(){
     System.out.println(&quot;wangwnagwang!!&quot;);
   }

   public String setColor(String color){
     this.color=color;
   }
   public void getColor(){
     return color;
   }

}

public class ExtndsDemo{
  public static void main(String[] args){
    Dog dog=new Dog();
    dog.setAge(5);
    dog.setWeight(10);
    dog.setColor(&quot;yellow&quot;);
    dog.speak();
System.out.println(&quot;age:&quot;+dog.getAge+&quot;,weight:&quot;+dog.getWeight+&quot;,color:&quot;+dog.getColor);


  }
}
</code></pre>
<p>运行结果:</p>
<pre><code class="java">wangwangwang!!
age:5,weight10,yellow</code></pre>
<h3 id="3-java继承的限制"><a href="#3-java继承的限制" class="headerlink" title="3. java继承的限制"></a>3. java继承的限制</h3><ul>
<li><p>限制一:java只允许单继承<br>即:</p>
<pre><code class="java">class A {}
class B extends A {}
class C extends B {}</code></pre>
</li>
<li><p>限制二:<br>在一个子类继承的时候，实际上会继承父类之中的所有操作（属性、方法），但是需要注意的是，对于所有的非私有（no private）操作属于显式继承（可以直接利用对象操作），而所有的私有操作属于隐式继承（间接完成）。</p>
</li>
<li><p>限制三:<br>在继承关系之中，如果要实例化子类对象，会默认先调用父类构造，为父类之中的属性初始化，之后再调用子类构造，为子类之中的属性初始化，即：默认情况下，子类会找到父类之中的无参构造方法。</p>
</li>
</ul>
<h3 id="4-动态绑定"><a href="#4-动态绑定" class="headerlink" title="4.动态绑定"></a>4.动态绑定</h3><ul>
<li>1.动态方法的绑定</li>
</ul>
<p>将一个方法同一个方法主体连接在一起就称为绑定(Binding)。若在运行运行前执行绑定，就称为“早期绑定”。上面的例子中，在只有一个Dog句柄的情况下，编译器不知道具体调用哪个方法。Java实现了一种方法调用机制，可在运行期间判断对象的类型，然后调用相应的方法，这种在运行期间进行，以对象的类型为基础的绑定称为动态绑定。除非一个方法被声明为final，Java中的所有方法都是动态绑定的。</p>
<p>用一张图表示上溯造型的继承关系</p>
<p><img src="images/2019/05/binding.png" alt="binding"></p>
<p>用代码概括为：</p>
<pre><code class="java">Shape s = new Shape();</code></pre>
<p>按照继承关系，将创建的Circle对象句柄赋给一个Shape是合法的，因为Circle属于Shape的一种。</p>
<p>当调用其中一个基础类方法时：</p>
<pre><code class="java">Shape s = new Shape();</code></pre>
<p>此时，调用的是Circle.draw(),这是由于动态绑定的原因。</p>
<p>动态绑定代码示例:</p>
<pre><code class="java">class Person {
    void eat() {}
    void speak() {}
}
class Boy extends Person {
    void eat() {
        System.out.println(&quot;Boy.eat()&quot;);
    }
    void speak() {
        System.out.println(&quot;Boy.speak()&quot;);
    }
}
class Girl extends Person {
    void eat() {
        System.out.println(&quot;Girl.eat()&quot;);
    }
    void speak() {
        System.out.println(&quot;Girl.speak()&quot;);
    }
}
public class Persons {
    public static Person randPerson() {
        switch ((int)(Math.random() * 2)) {
        default:
        case 0:
            return new Boy();
        case 1:
            return new Girl();
        }
    }
    public static void main(String[] args) {
        Person[] p = new Person[4];
        for (int i = 0; i &lt; p.length; i++) {
            p[i] = randPerson();    // 随机生成Boy或Girl
        }
        for (int i = 0; i &lt; p.length; i++) {
            p[i].eat();
        }
    }
}
</code></pre>
<p>对所有从Person衍生出来的类，Person建立了一个通用接口，所有衍生的类都有eat和speak两种行为。衍生类覆盖了这些定义，重新定义了这两种行为。在主类中，randPerson随机选择Person对象的句柄。上溯造型是在return语句里发生的。return语句取得一个Boy或Girl的句柄并将其作为Person类型返回，此时并不知道具体是什么类型，只知道是Person对象句柄。在main方法中调用randPerson方法为数组填入Person对象，但不知具体情况。当调用数组每个元素的eat方法时，动态绑定的作用就是执行对象的重新定义了的方法。</p>
<p><strong><code>然而，动态绑定是有前提的，绑定的方法必须存在于基类中，否则无法编译通过。</code></strong></p>
<pre><code class="java">class Person {
    void eat() {
        System.out.println(&quot;Person.eat()&quot;);
    }
}
class Boy extends Person {
    void eat() {
        System.out.println(&quot;Boy.eat()&quot;);
    }
    void speak() {
        System.out.println(&quot;Boy.speak()&quot;);
    }
}
public class Persons {
    public static void main(String[] args) {
        Person p = new Boy();
        p.eat();
        p.speak();  // The method speak() is undefined for the type Person
    }
}</code></pre>
<pre><code class="java">如果子类中没有定义覆盖方法，则会调用父类中的方法：

复制代码
class Person {
    void eat() {
        System.out.println(&quot;Person.eat()&quot;);
    }
}
class Boy extends Person {
}
public class Persons {
    public static void main(String[] args) {
        Person p = new Boy();
        p.eat();
    }
}</code></pre>
<p>【运行结果】:</p>
<pre><code class="java">Person.eat()</code></pre>
<h3 id="5-静态方法的绑定"><a href="#5-静态方法的绑定" class="headerlink" title="5.静态方法的绑定"></a>5.静态方法的绑定</h3><p>将上面的方法都加上static关键字，变成静态方法：</p>
<pre><code class="java">class Person {
    static void eat() {
        System.out.println(&quot;Person.eat()&quot;);
    }
    static void speak() {
        System.out.println(&quot;Person.speak()&quot;);
    }
}
class Boy extends Person {
    static void eat() {
        System.out.println(&quot;Boy.eat()&quot;);
    }
    static void speak() {
        System.out.println(&quot;Boy.speak()&quot;);
    }
}
class Girl extends Person {
    static void eat() {
        System.out.println(&quot;Girl.eat()&quot;);
    }
    static void speak() {
        System.out.println(&quot;Girl.speak()&quot;);
    }
}
public class Persons {
    public static Person randPerson() {
        switch ((int)(Math.random() * 2)) {
        default:
        case 0:
            return new Boy();
        case 1:
            return new Girl();
        }
    }
    public static void main(String[] args) {
        Person[] p = new Person[4];
        for (int i = 0; i &lt; p.length; i++) {
            p[i] = randPerson();    // 随机生成Boy或Girl
        }
        for (int i = 0; i &lt; p.length; i++) {
            p[i].eat();
        }
    }
}
</code></pre>
<pre><code class="java">【运行结果】：
Person.eat()
Person.eat()
Person.eat()
Person.eat()</code></pre>
<p>结论:<br><strong>观察结果，对于静态方法而言，不管父类引用指向的什么子类对象，调用的都是父类的方法。</strong></p>
<h3 id="方法绑定的总结"><a href="#方法绑定的总结" class="headerlink" title="方法绑定的总结"></a>方法绑定的总结</h3><ul>
<li>静态方法:静态方法看父类</li>
<li>非静态方法：非静态方法看子类</li>
</ul>

                <hr>
                <div>
                    <p>
                        
                    </p>
                </div>
                <br>
                
                    <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
                
            </div>
        </div>
        <div class="d-none d-md-block col-md-2">
            
  <div id="toc" class="py-5">
    <p class="h6"><i class="iconfont icon-toc" style="vertical-align:middle"></i> Toc:</p> 
    <div id="tocbot"></div>
  </div>

        </div>
    </div>        
</div>

<br><br><br>

<!-- Comments -->
<div class="comments" id="comments">
 
</div>
  
  </main>

<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank"><b>HEXO</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank"> <b>Material-T</b></a>
  </div>
</footer>

  <!-- SCRIPTS -->
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/jquery-3.3.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/bootstrap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/mdb.min.js"></script>
  <script src="/js/main.js"></script>
  
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    
    <script src="/js/post.js"></script>
    
      <script src="/js/plugins/prettify.js"></script>
      <script>
          $(document).ready(function(){
              $('pre').addClass('prettyprint linenums');
              prettyPrint();
          })
      </script>
    
  
</body>
</html>